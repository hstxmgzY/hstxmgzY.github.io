# 信息安全技术

## 第一部分 网络安全概论

### 数据

#### 什么是数据？

+ 任何可以被计算机处理和执行的对象

#### 数据的两种状态 

+ 传输状态
+ 存储状态

### 计算机安全最核心的三个关键目标 —— CIA 三元组

#### 保密性 (Confidentiality) 

该术语包含两个相关的概念：

+ **数据保密性**
	+ 确保隐私或秘密信息不向非授权者泄露， 也不被非授权者使用。
+ **隐私性** 
	+ 确保个人能够控制或确定与其自身相关的哪些信息是可以被收集的、被保存的，这些信息可以由谁来公开以及向谁公开。

#### 完整性 (Integrity) 

该术语包含两个相关的概念：

+ **数据完整性**
	+ 确保信息和程序**只能以特定和授权的方式**进行改变。
+ **系统完整性** 
	+ 确保系统以一种正常方式来执行预定的功能.，**免于有意或无意的非授权操纵**。

#### 可用性 (Availability) 

+ 确保系统能工作迅速.，**对授权用户不能拒绝服务**。

### 安全服务

#### 认证

+ **保证通信的实体是它所声称的实体**

##### 同等实体认证

+ 用于逻辑连接时为连接的实体的身份提供可信性

##### 数据源认证

+ 在无连接传输时保证收到的信息来源是声称的来源

#### 访问控制

+ 阻止对资源的**非授权使用**（即这项服务控制谁能访问资源，在什么条件下可以访问， 这些访问的资源可用于做什么）

##### 数据保密性

+ 保护数据免于非授权泄露

##### 连接保密性

+ 保护**一次连接**中所有的用户数据

##### 无连接保密性

+ 保护**单个数据块**中的所有用户数据

##### 选择域保密性

+ 对一次连接或单个数据块中指定的数据部分提供保密性

##### 流量保密性

+ 保护那些可以通过观察流而获得的信息

#### 数据完整性

+ 保证收到的数据的确是**授权实体**发出的数据 （即**未修改、插入、删除或重播**）

##### 具有恢复功能的连接完整性

+ 提供一次连接中所有用户数据的完整性，检测整个数据序列内存在的修改、插入、删除或重播，且试图恢复之。

##### 无恢复的连接完整性

+ 同上， 但仅提供检测， 无恢复

##### 选择域连接完整性

+ 提供次连接中传输的单个数据块内用户敢据的指定部分的完整性，井判断指定部分是否有修改、插入、删除或重播

##### 无连接完整性

+ 为单个无连接数据块提供完整性保护. 并检测是内有数据修改。另外，提供有限的重播检测

##### 选择域无连接完整性

+ 为单个无连接数据块内指定域提供完整性保护： 判断指定域是否被修改

#### 不可否认性

+ 防止整个或部分通信过程中，任一通信实体进行否认的行为

##### 源不可否认性

+ 证明消息是由特定方发出的

##### 宿不可否认性

+ 证明消息被特定方收到



### 特定安全机制

可以并入适当的协议层以提供一些OSI安全服务

#### 加密

+ 运用数学算法将数据转换成不可知的形式。数据的变换和还原依赖算法和零个或多个加密密钥。

#### 数字签名

+ 附加于数据单元之后的一种数据，它是对数据单元的密码变换，以使得（如接收方）可证明数据源和完整性，并防止伪造

#### 访问控制

+ 对资源行使访向控制的各种机制

#### 数据完整性

+ 用于保证数据单元或数据单元流的完整性的各种机制

#### 认证交换

+ 通过信息交换来保证实体身份的各种机制

#### 流量填充

+ 在数据流空隙中插入若干位以阻止流量分析

#### 路由控制

+ 能够为某些数据选择特殊的物理上安全的路线，并允许路由变化（尤其是在怀疑有侵犯安全的行为时）

#### 公证

+ 利用可信的第三方来保证数据交换的某些性质

### 安全服务与机制之间的联系

**安全服务通过各种安全机制实现**。不同的安全机制可以**独立或联合使用**，以确保数据在传输过程中满足特定的安全需求，从而达到全面的安全保护。

![截屏2024-06-14 00.46.13](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-14%2000.46.13.png)

### 中间人攻击

![image-20240614004716739](%E5%A4%8D%E4%B9%A0.assets/image-20240614004716739.png)

## 第二部分 加密算法

+ 通常的加密方法使用密钥和密码算法
  + 传统加密 (也称为：对称加密): 加密和解密使用相同的密钥
  + 公钥加密 (也称为：非对称加密):加密和解密使用不同的密钥

### 对称加密

#### 传统加密算法

##### 凯撒Caesar 密码

+ 用它之后的k个来代替

##### 单表替代密码

+ 每个明文字母都被替换为另一个唯一的字母或符号。这个替换过程是通过一个固定的替换表（或密钥表）来实现的。在这种加密方法中，明文字母和密文字母之间存在一一对应的关系。

##### Playfair加密（重要）

1. 画出填充矩阵（5✖️5） 注意 i和j 放在一个格子里
	1. 密钥词（去掉重复）之后填入格子
	2. 把其他字母按顺序填入剩余的格子
2. 开始加密—— **两个字母为一组**
	1. 如果两个字母相同/字母落单了——在他们中间再加一个填充字母X/在最后一个字母后面加X
		1. balloon——ba lx lo on
	2. 同一行——用**右边**的字母代替他自己（最右边的用最左边的第一个字母代替）
	3. 同一列——用**下面**的字母代替他自己（最下面的用最上面的第一个字母代替）
	4. 其他——到对方的列去（行不变）

![截屏2024-06-14 16.33.12](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-14%2016.33.12.png)

##### 多表替代方法

Vigenere密码：在Caesar的基础上增加密钥词，密钥是一个密钥词的重复。

Vigenère密码是一种基于多表替换的加密方法，使用一个密钥对明文进行加密。加密和解密的公式如下：

###### 加密公式

给定一个明文字符 \( P_i \) 和一个密钥字符 \( K_i \)，密文字符 \( C_i \) 的计算公式为：

\[ C_i = (P_i + K_i) \mod 26 \]

其中：



- \( P_i \) 是明文字符在字母表中的位置（例如，A=0, B=1, ..., Z=25）。
- \( K_i \) 是密钥字符在字母表中的位置。
- \( C_i \) 是生成的密文字符在字母表中的位置。

###### 解密公式

给定一个密文字符 \( C_i \) 和一个密钥字符 \( K_i \)，明文字符 \( P_i \) 的计算公式为：

\[ P_i = (C_i - K_i + 26) \mod 26 \]

其中：



- \( C_i \) 是密文字符在字母表中的位置。
- \( K_i \) 是密钥字符在字母表中的位置。
- \( P_i \) 是还原的明文字符在字母表中的位置。

###### 示例

假设明文是 "HELLO" 和密钥是 "KEY"。

1. **明文和密钥对齐**：

```
明文:  H  E  L  L  O
密钥:  K  E  Y  K  E
```

2. **将字符转换为数字**（A=0, B=1, ..., Z=25）：

```
明文:  7  4  11  11  14
密钥:  10  4  24  10  4
```

3. **加密**：

```
密文:  (7+10) mod 26 = 17  (4+4) mod 26 = 8  (11+24) mod 26 = 9  (11+10) mod 26 = 21  (14+4) mod 26 = 18
       R   I   J   V   S
```

加密结果是 "RIJVS"。

4. **解密**：

将密文 "RIJVS" 和密钥 "KEY" 对齐，并将字符转换为数字：

```
密文:  17  8  9  21  18
密钥:  10  4  24  10  4
```

使用解密公式计算明文：

```
明文:  (17-10+26) mod 26 = 7  (8-4+26) mod 26 = 4  (9-24+26) mod 26 = 11  (21-10+26) mod 26 = 11  (18-4+26) mod 26 = 14
       H   E   L   L   O
```

解密结果是 "HELLO"。

###### 注意事项

1. **密钥长度**：密钥通常会重复使用，以匹配明文的长度。
2. **大写字母**：Vigenère密码通常对大写字母进行操作。对于小写字母，可以先将其转换为大写。
3. **字符范围**：公式中的所有字符都应在0到25范围内进行模运算。

缺陷：密文依旧存在循环的统计特征，

解决方案：”密钥自动生成系统“的方案——将密钥词和明文自身连接起来以便生成不重复的密钥词。

#### 现代加密算法

##### **AES（高级加密标准）**

密钥的长度可以为128（10个加密循环）、192（12）和256（14）位，也就是16个字节、24个字节和32个字节

1. **初始状态矩阵**（先排列再排行）
2. 初始化轮密钥加后的状态矩阵（异或一下）
3. 字节替代（考不来 不会考的）
4. 行移位后的状态矩阵
	1. 第一行不变
	1. 第二行向左移动一位
	1. 第三行向左移动两位
	1. 第四行向左移动三位
5. 列混淆矩阵（感觉也不会考 摆烂放弃了） 毕竟矩阵乘法还是懒得乘的

![1-2](%E5%A4%8D%E4%B9%A0.assets/1-2.png)

##### DES（数据加密标准）

密钥的长度64位，8个字节。

##### 标准的分组密码的工作模式

###### 电子密码本 (ECB-Electronic Code Book) 

+ 每一组独立做加密处理
+ ![image-20240614153232500](%E5%A4%8D%E4%B9%A0.assets/image-20240614153232500.png)
+ ![image-20240614153832363](%E5%A4%8D%E4%B9%A0.assets/image-20240614153832363.png)

###### 密码块链接 (CBC-Cipher Block Chaining) 

+ 哈希

![image-20240614155408225](%E5%A4%8D%E4%B9%A0.assets/image-20240614155408225.png)

CBC模式也可以用于生成一种哈希值。这个过程可以被看作是将一个长消息压缩成一个固定长度的摘要。其工作原理如下：

1. **初始向量 (IV)**:
   
	- 选择一个初始向量 (IV)，通常为零向量或其他固定值。
   
2. **加密过程**:
   
	- 将消息分成固定大小的分组（例如128位）。
	- 第一个消息块 $M_1$ 与 IV 进行异或操作，然后加密得到第一个密文块 $C_1$：$C_1 = E_K(M_1 \oplus IV)$
	- 第二个消息块 $M_2$ 与第一个密文块 $C_1$ 进行异或操作，然后加密得到第二个密文块 $C_2$：$C_2 = E_K(M_2 \oplus C_1)$
   - 以此类推，直到处理完最后一个消息块 $M_n$：$C_n = E_K(M_n \oplus C_{n-1})$
   - 最**终的哈希值就是最后一个密文**块 $C_n$。

这种方式可以看作是一种压缩函数，但它缺乏专用哈希函数（如SHA-256）的安全特性。

总结起来，CBC模式虽然主要用于加密，但它在消息认证码（CBC-MAC）中的应用以及与哈希函数的结合使用展示了其灵活性和广泛应用的可能性。

电子密码本 (ECB - Electronic Code Book) 是一种简单的分组密码工作模式，但它有一些显著的缺点，主要包括以下几个方面：

1. **缺乏随机性**：
	- 在ECB模式下，**相同的明文块总是被加密成相同的密文块**。这意味着如果有重复的明文块，它们会在密文中表现出相同的模式，从而使攻击者可以识别这些重复块并推测出某些明文的信息。

2. **无法隐藏数据模式**：
	- 由于相同的明文块会产生相同的密文块，攻击者可以通过观察密文的模式来获取关于明文结构的信息。例如，对于图像数据来说，使用ECB模式加密后的图像仍然能够看出原始图像的大致轮廓。

3. **不具备前向和后向保密性**：
	- 如果某个密文块被破解了，它**不会影响其他密文块**的安全性。这意味着攻击者可以单独攻击每个密文块，而不需要考虑其他块的加密结果。

CBC (Cipher Block Chaining) 模式克服了ECB模式的这些缺点：

1. **引入随机性**：
	- 在CBC模式下，每个明文块在加密之前都会与前一个密文块进行异或操作。第一个明文块会与一个初始化向量 (IV) 进行异或操作。这意味着即使两个相同的明文块也会因为不同的前置密文块或IV而生成不同的密文块。

2. **隐藏数据模式**：
	- 由于每个明文块在加密之前都与前一个密文块进行了异或操作，这打破了明文块之间的直接联系，从而消除了密文中的模式。这样，即使是加密图像数据，密文也不会显现出原始图像的结构。

3. **增强前向和后向保密性**：
	- 在CBC模式中，每个密文块的生成不仅依赖于当前的明文块，还依赖于前一个密文块。因此，解密某个密文块需要知道前一个密文块的值。这增加了攻击者单独破解每个密文块的难度。

## **第三部分 公钥密码体系与密钥管理**

主要考**计算题** DH和RSA

+ **公钥密码体系能够提供数据认证和抗抵赖功能**
  + **身份验证**：通过私钥加密的信息可以验证消息发送者的身份。这在数字签名中非常重要，数字签名用于证明消息或文档未被篡改过，并确认发送者的身份。
  + **抗否认性**：使用私钥加密的数字签名还提供了抗否认性，意味着消息的发送者无法否认他们发送了该消息。这一点在法律和商业通信中尤为重要，因为它为交易和消息提供了一种形式的法律证明。


### 术语

+ **非对称加密**
	+ 两个密钥，用来实现互补运算，即加密和解密，或者生成签名和验证签名
+ **公钥证书**
	+ 认证机构将用户的姓名和公钥绑定在一起，用户用自己的私钥对数字文件签名后，可以通过证书识别签名者，因为签名者是唯一拥有与证书上对应的私钥的用户。
+ **公钥密码（非对称密码）算法**
	+ 含有两个密钥：公钥和私钥，从公钥推出私钥在计算上不可行
+ **公钥基础设施**（PKI）
	+ 由一系列的协议、服务平台、软件和工作站组成，用于管理证书和公钥一私钥对，并产生、维护和废除公钥证书。
+ 选择密文攻击（Chosen Ciphertext Attack，简称CCA）
	+ 是一种密码分析攻击方式，攻击者能够解密某些密文，并通过这些解密的结果，试图破解整个加密系统。
	

### 公钥密码体系的组成部分

+ **明文**：算法的输入。它们是可读信息或数据。
+ **加密算法**：加密算法对明文进行各种转换。
+ **公钥和私钥**： 算法的输入。这对密钥中一个用于加密，一个用于解密。加密算法执行的变换依赖于公钥或者私钥。
+ **密文**： 算法的输出。它依赖明文和密钥， 对给定的消息， 不同的密钥产生的密文不同。
+ **解密算法**： 该算法接收密文和相应的密钥， 并产生原始的明文。

### RSA算法（考）

RSA（Rivest-Shamir-Adleman）算法是一种广泛使用的公钥加密算法，用于安全数据传输。它基于数论中的大数分解问题，是最早实现公钥加密和数字签名的一种算法。以下是对RSA算法的详细解释，包括其原理、关键生成、加密、解密过程以及安全性。

#### RSA算法的原理

RSA算法的安全性基于大整数的质因数分解的难题，即在知道一个大整数的情况下，找到其两个质因数是计算上不可行的。

#### 密钥生成（Key Generation）

1. **选择两个大质数 \( p \) 和 \( q \)**：
	- 选择两个不同的大质数 \( p \) 和 \( q \)，它们需要足够大以保证安全性。
2. **计算 \( n \) 和 \( \phi(n) \)**：
	- \( n = p \times q \)
	- \( \phi(n) = (p-1) \times (q-1) \)
	- 其中 \( n \) 称为**模数**， \( \phi(n) \) 称为**欧拉函数**。
3. **选择公钥指数 \( e \)**：
	- 选择一个与 \( \phi(n) \) **互质**的整数 \( e \)，通常选用常见的 \( e \) 值如 3、17 或 65537，因为它们可以简化计算。
4. **计算私钥指数 \( d \)**：重要‼️
	- 计算 \( d \)，使得 \( d \equiv e^{-1} \mod \phi(n) \)，即 \( d \times e \equiv 1 \mod \phi(n) \)。
	- 这里 \( d \) 是 \( e \) 在模 \( \phi(n) \) 下的乘法逆元。
	- 例子：在使用 RSA 的公钥体制中，已截获发给某用户的密文$C=10$，该用户的公钥$e=5$,$n=35$。那么明文$M$是多少？
		- $n = p\times q$
		- 令$p=5$，$q=7$
		- $\phi(n) = (p-1) \times (q-1)=24$
		- $d \times e \equiv 1 \mod \phi(n)$
		- $d = 5$
		- $M= C^d \mod n = 100000 \mod 35 = 5$
5. **公钥和私钥**：
	- 公钥 \( (e, n) \)
	- 私钥 \( (d, n) \)

#### 加密过程（Encryption）

1. **将明文转换为整数 \( m \)**：
	- 将要加密的明文 \( m \) 转换为一个小于 \( n \) 的整数。
   
2. **计算密文 \( c \)**：
	- 使用公钥 \( (e, n) \) 进行加密。
	- \( c = m^e \mod n \)
   
3. **得到密文**：
	- \( c \) 即为密文。

#### 解密过程（Decryption）

1. **接收密文 \( c \)**：
	- 接收方使用私钥 \( (d, n) \) 进行解密。

2. **计算明文 \( m \)**：
	- \( m = c^d \mod n \)

3. **得到明文**：
	- \( m \) 即为解密后的明文。

#### 示例

假设选择两个质数 \( p = 61 \) 和 \( q = 53 \)：

1. **计算 \( n \) 和 \( \phi(n) \)**：
	- \( n = 61 \times 53 = 3233 \)
	- \( \phi(n) = (61-1) \times (53-1) = 3120 \)

2. **选择 \( e \)**：
	- 选择 \( e = 17 \)，它与 \( \phi(n) \) 互质。

3. **计算 \( d \)**：
	- \( d = 2753 \)（满足 \( 17 \times 2753 \equiv 1 \mod 3120 \)）

4. **公钥和私钥**：
	- 公钥：\( (17, 3233) \)
	- 私钥：\( (2753, 3233) \)

5. **加密**：
	- 将明文 \( m = 123 \) 进行加密。
	- \( c = 123^{17} \mod 3233 = 855 \)

6. **解密**：
	- 使用密文 \( c = 855 \) 进行解密。
	- \( m = 855^{2753} \mod 3233 = 123 \)

用图9.5所示的 RSA 算法对下列数据实现加密和解密

1. p=3; q=11, e=7; M=5
2. p=5: q=11, e=3: M=9
3. p=7: q=11, e 17; M=8

#### 安全性

RSA的安全性主要依赖于大整数分解的难度。具体来说，RSA的安全性基于以下几个方面：

1. **大整数分解**：
	- RSA的安全性依赖于在合理时间内无法将大整数 \( n \) 分解为两个质数 \( p \) 和 \( q \)。

2. **私钥保护**：
	- 私钥必须保密，泄露私钥将导致安全性问题。

3. **密钥长度**：
	- 密钥长度决定了RSA的安全强度。常见的密钥长度为2048位或更长，以应对未来计算能力的提升。

#### RSA公钥分发问题

RSA算法中的公钥分发涉及到如何安全地将公钥传递给需要加密数据的各方。尽管RSA是一种非常强大的加密算法，但在公钥的分发过程中仍然存在一些潜在的问题和挑战：

1. **中间人攻击（Man-in-the-Middle Attack）**
	- 在公钥分发过程中，如果攻击者能够拦截并替换公钥，就可以实施中间人攻击。**攻击者可以生成自己的公钥并将其发送给通信的双方**，从而能够**解密和篡改通信内容**。

2. **公钥伪造（Key Forgery）**
	- **没有经过验证**的公钥可能是伪造的。如果没有**可靠的机制**来验证公钥的真实性，攻击者可以伪造公钥并冒充另一个用户。
3. **公钥传输的完整性（Integrity of Key Transmission）**
	- 在公钥传输过程中，公钥的**完整性**必须得到保证。如果公钥在传输过程中被修改或损坏，将导致通信失败或安全漏洞。

4. **信任问题（Trust Issues）**
	- 如何确保接收到的公钥是可信的？这涉及到信任链的问题。如果没有一个可信的第三方机构（如证书颁发机构）来验证公钥的真实性，用户很难确定公钥是否可靠。

5. **公钥存储的安全性（Security of Public Key Storage）**
	- 即使公钥分发过程是安全的，公钥的存储也必须是安全的。存储在不安全位置的公钥可能被攻击者替换或篡改。

6. **公钥撤销（Key Revocation）**
	- 如果公钥泄露或不再可信，需要一种机制来撤销公钥。如果没有有效的公钥撤销机制，旧的公钥可能仍然被使用，从而带来安全风险。

##### 解决方案

为了应对这些问题，可以采用以下方法：

1. **使用证书和PKI（Public Key Infrastructure）**：
	- 通过**证书颁发机构（CA）**签发的数字证书来验证公钥的真实性。CA的公钥在用户设备中预先安装，从而建立信任链。
   
2. **公钥指纹验证**：
	- 在初次通信时，通过另一种安全渠道（如面对面、电话）交换公钥指纹。双方可以验证指纹是否匹配，以确保公钥未被篡改。

3. **双因素验证**：
	- 在公钥分发过程中，使用双因素验证来增加安全性。例如，要求用户在接收到公钥后通过SMS或电子邮件确认。

4. **分发公共密钥服务器**：
	- 使用可靠的公共密钥服务器（如PGP优良保密协议密钥服务器）来存储和分发公钥。这些服务器通常提供公钥验证和撤销功能。

5. **区块链技术**：
	- 使用区块链技术来存储和验证公钥，以确保公钥的不可篡改性和透明度。



### **DH密钥交换协议**（考）

Diffie-Hellman (DH) **密钥交换协议**是一种用于安全地在两个通信方之间建立共享秘密密钥的方法。DH协议本身并不是一种加密或解密算法，而是一个密钥交换机制，使得通信双方可以在不安全的信道上安全地生成共享密钥。共享密钥可以用于对称加密算法（如AES）进行加密和解密通信内容。

#### 原理

DH密钥交换基于**离散对数**问题的难解性。具体步骤如下：

1. **公开参数**：
	- 选择一个大素数 \( p \) 和一个基数 \( g \)，其中 \( g \) 是 \( p \) 的一个本原根。这些参数可以公开。

2. **密钥生成**：
	- 每个参与者选择一个秘密私钥（私有数），通常称为 \( a \) 和 \( b \)。

3. **计算部分密钥**：
	- 每个参与者根据自己的私钥和基数计算出一个部分密钥，并将其公开。
	- 计算公式：
		- Alice 计算 \( A = g^a \mod p \) 并将 \( A \) 发送给 Bob。
		- Bob 计算 \( B = g^b \mod p \) 并将 \( B \) 发送给 Alice。

4. **计算共享密钥**：
	- 每个参与者使用对方的部分密钥和自己的私钥计算出共享密钥。
	- 计算公式：
		- Alice 计算共享密钥 \( s = B^a \mod p \)。
		- Bob 计算共享密钥 \( s = A^b \mod p \)。
	- 由于 \( B = g^b \) 和 \( A = g^a \)，共享密钥 \( s \) 的值相同：
		- \( s = (g^b)^a \mod p = (g^a)^b \mod p \)。

这个共享密钥可以用于对称加密算法，例如AES，用于加密和解密通信内容。

#### 示例

假设选择素数 \( p = 23 \) 和基数 \( g = 5 \)。


- **Alice 和 Bob 选择私钥**：
	- Alice 选择私钥 \( a = 6 \)。
	- Bob 选择私钥 \( b = 15 \)。

- **计算部分密钥**：
	- Alice 计算 \( A = 5^6 \mod 23 = 8 \) 并将 \( A \) 发送给 Bob。
	- Bob 计算 \( B = 5^15 \mod 23 = 19 \) 并将 \( B \) 发送给 Alice。

- **计算共享密钥**：
	- Alice 计算共享密钥 \( s = 19^6 \mod 23 = 2 \)。
	- Bob 计算共享密钥 \( s = 8^15 \mod 23 = 2 \)。

因此，Alice 和 Bob 共享的秘密密钥是 2。

![截屏2024-06-28 22.55.27](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-28%2022.55.27.png)

![截屏2024-06-28 22.55.40](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-28%2022.55.40.png)

#### 安全性

DH密钥交换协议的安全性依赖于离散对数问题的难解性。即使攻击者知道 \( p \)、\( g \)、\( A \) 和 \( B \)，计算出 \( s \) 仍然是计算上不可行的。

#### 实际应用

DH密钥交换协议广泛用于各种安全通信协议中，例如：

- **TLS/SSL**：用于保护互联网通信的安全。
- **IPsec**：用于保护IP网络层的安全。
- **SSH**：用于保护远程登录的安全。

#### 变体

DH密钥交换协议有多种变体，包括：

- **椭圆曲线Diffie-Hellman（ECDH）**：基于椭圆曲线离散对数问题，提供更高的安全性和效率。
- **静态DH和临时DH**：在一些协议中，密钥交换的双方可能会在多个会话中重复使用相同的私钥（静态DH）或每次会话生成新的私钥（临时DH）。

## 第四部分 密码学中的数据完整性算法 

### 数字指纹

+ **不需要使用**秘密密钥而生成的一个长数据的**短的表示**，称为数字摘要或数字指纹
+ 数字指纹可以使用密码散列函数得到，又称为**单向散列函数**

#### 消息认证码 (MAC)

+ **使用**秘密密钥产生的数据的**短**表示，称为**消息认证码 (MAC)**或标签

+ MAC 可以通过加密的校验和算法得到
+ 带密钥的散列消息认证码(*HMAC*) 是密码散列函数和密码校验和算法的组合

#### 密码校验和

+ 校验和通常用于检测网络通信中的传输错误
  + 但是，这些校验和不能用于数据认证或数字指纹，因为很容易找到不同的消息具有相同的校验和
  + l我们可以用对称密码算法生成密码校验和，用于数据认证
+ 密码校验和又称为消息认证码 (MAC)

### 密码散列函数

+ 散列函数以一个长的消息为输入，分成若干部分后，进行“打碎重组”，产生一个新的短字符串。

#### 密码散列函数的设计要求——单向性、计算唯一性（无碰撞性、强无碰撞性）

+ 设 $H$表示一个散列函数, $Γ$ 是输入长度的上界, $γ$ 是比$Γ$小得多的固定的输出长度
+ **单向性**: 计算一个给定消息串的数字指纹是容易的, 但是找到一个数字指纹对应的消息是困难的
  + 对于任意的二进制串*x* ，其中 $|x| ≤ Γ$, 计算 $H(x)$是容易的, 但是对于一个给定的散列值 $h ( |h| = γ)$, 很难找到它对应的原像$x$使得$h = H(x)$​
+ **计算唯一性**: 找到两个不同的消息具有相同的数字指纹是困难的
  + 无碰撞性
    + 给定一个消息 $x$，满足$|x| ≤ Γ$, 找到另一个不同的消息$y (|y| ≤ Γ)$与$x$具有相同的散列值，即$H(x) = H(y)$，是困难的
  + **强**无碰撞性
    + **很难**找到两个消息$x$和$y$具有相同的散列，即$H(x) = H(y)$
  + 注意：不满足强无碰撞性，并不意味着不满足无碰撞性

#### 单项散列函数无法解决的问题

+ 单向散列函数可以实现**完整性检测**
+ 但很多情况下仅仅能够检测完整性是不够的
+ 不仅要确认完整性，还需要确认来源（也即**认证**）
+ 用于认证的技术包括
  + 消息认证码：能够向通信对象保证消息没有被篡改
  + 数字签名：不仅能向通信对象保证消息没有被篡改，还能向所有第三方做出这样的保证。（公钥技术）



### **数字签名标准** **(DSS)**

+ 只生成数字签名, 不加密数据

### **双签名与电子交易**

+ 双签名是一种用于电子交易的交互式认证协议
  + 提供安全和隐私性保护
  + 在SET协议 (Secure Electronic Transactions)中使用, 此协议是由Visa 和 MasterCard 在1996年设计的，但是没有在实际中推广需要 
+ Alice, Bob和Charlie 协商确定使用的散列函数$H$ 和公钥加密算法$E$
+ Alice, Bob和Charlie 必须各自有一对RSA密钥对: $(K_A^u, K_A^r)$, $(K_B^u, K_B^r)$, $(K_C^u, K_C^r)$

![image-20240616200531039](%E5%A4%8D%E4%B9%A0.assets/image-20240616200531039.png)

![image-20240616200908961](%E5%A4%8D%E4%B9%A0.assets/image-20240616200908961.png)

### 小结

![image-20240616202040474](%E5%A4%8D%E4%B9%A0.assets/image-20240616202040474.png)

## 第五部分 互信

两个通信方之间分发密钥的方法。

### 基于对称加密的对称密钥分发

### 基于对称加密的对称密钥分发

## 第六部分 网络与Internet安全

### 不同层次实施安全协议的优缺点

#### 应用层 —— S/MIME, PGP, PEM, SET, Kerberos, SHTTP, SSH

+ 提供**端对端**安全保护
+ **不需要**解密数据或验证签名
+ 攻击者能**够分析流量以及修改报头**

#### 传输层 —— SSL / TLS

+ 提供**TCP包**的安全保护
+ **不需要**修改应用程序
+ 攻击者**可以通过IP包头分析网络流量**

#### 网络层 —— IP 安全性(IPSec)

+ 提供**链对链**的安全保护
  + **传输模式**: 只加密载荷
  + **隧道模式**: 加密包头和载荷，需要**网关**
+ 不需要修改任何应用程序

#### 数据链路层

+ 提供数据帧的安全保护
+ 不需要修改任何应用程序
+ 流量分析**不会泄露太多信息**

### 证书——解决数字签名无法直接解决的问题

+ 数字签名可以实现消息完整性的确认、身份认证以及防止否认。
+ 但前提是，用于验证签名的公钥必须属于真正的发送者。如果所得到的公钥是伪造的，那么数字签名也会完全失效。
+ 为了能够确认自己得到的公钥是否合法，需要使用**证书**。
+ 证书：就是将公钥作为一条消息，由一个可信的第三方对其进行签名（第三方的私钥）后所得到的公钥。

![image-20240616204436230](%E5%A4%8D%E4%B9%A0.assets/image-20240616204436230.png)

## 重要！PKI（Public Key Infrastructure，公钥基础设施）

+ 是一种系统和框架，用于管理、分发、存储和撤销数字证书及其公钥和私钥对。PKI的主要目标是提供安全的网络通信、身份验证、数据完整性和不可否认性。它是现代信息安全和加密技术的重要组成部分，广泛应用于电子商务、电子邮件、VPN、软件签名等领域。
+ PKI 是**使用公钥密码体系的机制**
+ PKI 负责签发、管理公钥证书
  + 确定用户的合法性
  + 根据用户的需求颁发公钥证书
  + 根据用户的需求延长证书的有效期
  + 根据用户的需求或当私钥泄露时，撤销证书
  + 存储和管理公钥证书
  + 防止签名者抵赖自己的签名
  + 支持CA 中心之间实现互相认证

## 重要！IPsec（Internet Protocol Security IP 安全性 互联网协议安全）

**IPsec**是一组协议，用于在互联网上通过加密和验证确保IP包的机密性、完整性和真实性。IPsec工作在网络层，可以保护所有通过IP传输的数据。

+ IPsec是网络层的协议

+ IPsec 实现对IP包的加密和认证，包括3个协议:
  + **认证头协议(AH)**Authentication Header
    + 认证IP包的来源和完整性
    + 用**滑动窗口**防御消息重放攻击
  + **封装安全载荷协议(ESP)** Encapsulating Security Payload
    + 加密和认证IP包
  + **互联网密钥交换协议(IKE)**Internet Key Exchange
    + 用于通信双方协商密钥
    + 加密和认证都要求通信双方拥有共同密钥
    + 手工和自动（IKE)
    + IKE
      + Oakley密钥确定协议（DH+身份认证）
      + ISAKMP密钥管理协议（互联网安全联盟和密钥管理协议）（只规定了交换格式，未规定密钥交换算法）

+ 两种运行模式
  + 传输模式（主要用于端到端通信，如客户端和服务器之间的，保护的是传输层协议（TCP/UDP）的数据部分，不包括IP头）
  + 隧道模式(需要网关，主要用于网关到网关，主机到网关，网关到主机的通信，加密/认证整个IP数据包，并封装在一个新的数据包中，添加新的IP头)‏

![image-20240616210045390](%E5%A4%8D%E4%B9%A0.assets/image-20240616210045390.png)

+ IPsec通过**AH和ESP为IP数据报**文提供安全服务
  + 不同的用户可能需要不同的安全服务
  + 同一用户不同的数据也有可能需要提供不同的安全服务。
  + 比如在一个公司里，有一个集中的管理部门，其内部的通信必须保证信息的完整性，但不需要加密；而管理部门和其他部门之间的通信则即需要保证信息完整性，又必须保证机密性。

+ IPsec可以通过两种协议来实现安全性：AH（Authentication Header）和ESP（Encapsulating Security Payload）。

  + **AH（Authentication Header）**认证头：

    - 提供数据完整性和身份验证。

    - 不提供数据加密。

    - AH头部插入在IP头部和传输层协议（如TCP/UDP）头部之间。

  + **ESP（Encapsulating Security Payload）** 封装安全载荷：

    - 提供数据加密、完整性和身份验证。

    - ESP头部插入在IP头部和传输层协议头部之间。

    - ESP尾部和认证数据附加在IP包末尾。

### IPsec的主要功能

1. **数据加密**：使用对称加密算法（如AES、3DES）对IP包进行加密，确保数据的机密性。
2. **数据完整性和验证**：使用哈希算法（如SHA-256）和密钥认证码（HMAC）确保数据的完整性和真实性。
3. **密钥交换**：使用Internet Key Exchange（IKE）协议进行密钥协商和管理，确保密钥的安全交换。
4. **隧道模式和传输模式**：IPsec有两种工作模式：
   - **隧道模式**：整个IP包被加密并封装在一个新的IP包中，通常用于VPN（虚拟专用网络）。
   - **传输模式**：仅加密IP包的有效负载，保留原始IP头部，通常用于端到端的通信保护。

### IPsec包的结构

![image-20240616205005981](%E5%A4%8D%E4%B9%A0.assets/image-20240616205005981.png)

### 安全策略

+ **安全策略数据库（SPD）**
  + 库中的每条记录对应一个安全策略
+ 对我的所有访问都要进行身份验证 $\to$ 对目的地址为192.168.0.1的通信都要通过HMAC-SHA进行身份验证
+ 对于外出的数据报文，必须先检索SPD（决定提供给它什么样的安全服务）
+ 对于进入的数据报文，也要检索SPD，判断为该报文提供的安全服务是否和本地安全策略所规定的安全服务相符。

#### 安全策略的要素

+ 目的IP、源IP、传输层协议、源和目的端口等
+ 处理方式：丢弃、绕过、应用IPsec
+ 如果是**应用IPsec**，策略要包含使用的**安全协议（AH/ESP）、模式（传输/隧道）、算法（加密-认证）**等，这些参数以安全关联的形式存在**安全关联数据库中（SAD**）。

### 安全联盟(SA)

![image-20240616210946230](%E5%A4%8D%E4%B9%A0.assets/image-20240616210946230.png)

+ 当 Alice 要与Bob 建立 IPsec 连接, 双方首先需要协商使用的算法和密钥
+ 安全联盟就是为实现以上目的
+ 一个安全联盟(SA)在通信的发起者和响应者之间建立，在一个会话阶段内有效
+ **一个安全联盟(SA) 可以用于加密或者认证，但不能同时用于两者**
+ 如果一个连接既需要加密又需要认证，则需要**建立两个安全联结(SA)**，一个用于加密，另一个用于认证

#### 安全联盟的组成

+ 三个参数:
  + 安全参数索引(SPI)Security Parameter Index
  + 目标IP 地址
  + 安全协议标识符

+ 安全联盟数据库(SAD) Security Association Database
  + 在本地主机上存储安全联盟
+ 安全策略数据库(SPD) Security Policy Database
  + 一组对IP包进行加密或认证的策略
+ SA 选择器(SAS) 安全联盟选择器 (Security Association Selectors, SAS)
  + 指定每个安全联盟用于哪些IP包的规则

### 重要！IPsec 包的组成

![image-20240616211526768](%E5%A4%8D%E4%B9%A0.assets/image-20240616211526768.png)

![image-20240616211539571](%E5%A4%8D%E4%B9%A0.assets/image-20240616211539571.png)

![image-20240616211602344](%E5%A4%8D%E4%B9%A0.assets/image-20240616211602344.png)

### 阻塞攻击

+ 一种拒绝服务攻击
+ 攻击者在欺诈的IP包中发送大量的公钥$Y_i$ , 使得被攻击主机忙于进行大量的计算秘密密钥的运算$Ki = Y_iX mod p$
  + Diffie-Hellman密钥交换协议中的模幂运算是非常耗时的
+ **Cookies技术**
  + 在计算之前, 接收方向发起方发送一个cookie (随机数)，并等待发起方发回包含此cookie的确认信息
  + 这可以防止攻击者通过修改源IP地址来伪造大量的DH请求包



### **TLS（Transport Layer Security，传输层安全协议）**

+ 是一种用于在计算机网络上提供通信安全性的协议。TLS广泛应用于互联网通信中，用于保护数据传输的安全性和隐私性。它是**SSL（Secure Sockets Layer，安全套接字层）**的继任者。

### PGP（Pretty Good Privacy 优良保密协议）

+ **PGP**是一种数据加密和解密的计算机程序，提供加密和签名功能，主要用于保护电子邮件通信的隐私和验证电子邮件内容的完整性和发送者身份。它结合了对称密钥加密和非对称密钥加密的优点。

#### PGP的主要功能

1. **数据加密**：使用对称密钥算法（如AES）加密消息内容，确保消息的机密性。
2. **密钥加密**：对称密钥使用接收者的公钥加密，确保只有接收者能够解密。
3. **数字签名**：使用发送者的私钥对消息进行签名，接收者可以使用发送者的公钥验证消息的真实性和完整性。
4. **密钥管理**：PGP使用密钥环（keyring）管理公钥和私钥，支持多用户环境下的密钥交换和管理。

### 简述与复习思路

1. **理解PGP和IPsec的基本概念**：掌握PGP用于电子邮件加密和签名的基本原理和IPsec用于IP包加密和验证的机制。
2. **熟悉PGP和IPsec的工作流程**：理解PGP的密钥管理、加密和签名流程，以及IPsec的隧道模式和传输模式的应用场景。
3. **了解协议和算法**：掌握PGP和IPsec中使用的主要加密算法（如AES、RSA）、哈希算法（如SHA-256）、认证算法（如HMAC）和密钥交换协议（如IKE）。
4. **应用场景**：通过实际应用场景（如安全电子邮件、VPN），理解PGP和IPsec在保护通信中的作用。

通过系统学习PGP和IPsec的基本原理、工作机制和实际应用，可以全面理解这两种技术在信息安全中的重要作用和应用。