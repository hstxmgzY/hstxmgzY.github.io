# 信息安全技术

## 第一部分 网络安全概论

### 数据

#### 什么是数据？

+ 任何可以被计算机处理和执行的对象

#### 数据的两种状态 

+ 传输状态
+ 存储状态

### 计算机安全最核心的三个关键目标 —— CIA 三元组

#### 保密性 (Confidentiality) 

该术语包含两个相关的概念：

+ **数据保密性**
	+ 确保隐私或秘密信息不向非授权者泄露， 也不被非授权者使用。
+ **隐私性** 
	+ 确保个人能够控制或确定与其自身相关的哪些信息是可以被收集的、被保存的，这些信息可以由谁来公开以及向谁公开。

#### 完整性 (Integrity) 

该术语包含两个相关的概念：

+ **数据完整性**
	+ 确保信息和程序**只能以特定和授权的方式**进行改变。
+ **系统完整性** 
	+ 确保系统以一种正常方式来执行预定的功能.，**免于有意或无意的非授权操纵**。

#### 可用性 (Availability) 

+ 确保系统能工作迅速.，**对授权用户不能拒绝服务**。

### 安全服务

#### 认证

+ **保证通信的实体是它所声称的实体**

##### 同等实体认证

+ 用于逻辑连接时为连接的实体的身份提供可信性

##### 数据源认证

+ 在无连接传输时保证收到的信息来源是声称的来源

#### 访问控制

+ 阻止对资源的**非授权使用**（即这项服务控制谁能访问资源，在什么条件下可以访问， 这些访问的资源可用于做什么）

##### 数据保密性

+ 保护数据免于非授权泄露

##### 连接保密性

+ 保护**一次连接**中所有的用户数据

##### 无连接保密性

+ 保护**单个数据块**中的所有用户数据

##### 选择域保密性

+ 对一次连接或单个数据块中指定的数据部分提供保密性

##### 流量保密性

+ 保护那些可以通过观察流而获得的信息

#### 数据完整性

+ 保证收到的数据的确是**授权实体**发出的数据 （即**未修改、插入、删除或重播**）

##### 具有恢复功能的连接完整性

+ 提供一次连接中所有用户数据的完整性，检测整个数据序列内存在的修改、插入、删除或重播，且试图恢复之。

##### 无恢复的连接完整性

+ 同上， 但仅提供检测， 无恢复

##### 选择域连接完整性

+ 提供次连接中传输的单个数据块内用户敢据的指定部分的完整性，井判断指定部分是否有修改、插入、删除或重播

##### 无连接完整性

+ 为单个无连接数据块提供完整性保护. 并检测是内有数据修改。另外，提供有限的重播检测

##### 选择域无连接完整性

+ 为单个无连接数据块内指定域提供完整性保护： 判断指定域是否被修改

#### 不可否认性

+ 防止整个或部分通信过程中，任一通信实体进行否认的行为

##### 源不可否认性

+ 证明消息是由特定方发出的

##### 宿不可否认性

+ 证明消息被特定方收到



### 特定安全机制

可以并入适当的协议层以提供一些OSI安全服务

#### 加密

+ 运用数学算法将数据转换成不可知的形式。数据的变换和还原依赖算法和零个或多个加密密钥。

#### 数字签名

+ 附加于数据单元之后的一种数据，它是对数据单元的密码变换，以使得（如接收方）可证明数据源和完整性，并防止伪造

#### 访问控制

+ 对资源行使访向控制的各种机制

#### 数据完整性

+ 用于保证数据单元或数据单元流的完整性的各种机制

#### 认证交换

+ 通过信息交换来保证实体身份的各种机制

#### 流量填充

+ 在数据流空隙中插入若干位以阻止流量分析

#### 路由控制

+ 能够为某些数据选择特殊的物理上安全的路线，并允许路由变化（尤其是在怀疑有侵犯安全的行为时）

#### 公证

+ 利用可信的第三方来保证数据交换的某些性质

### 安全服务与机制之间的联系

**安全服务通过各种安全机制实现**。不同的安全机制可以**独立或联合使用**，以确保数据在传输过程中满足特定的安全需求，从而达到全面的安全保护。

![截屏2024-06-14 00.46.13](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-14%2000.46.13.png)

### 中间人攻击

![image-20240614004716739](%E5%A4%8D%E4%B9%A0.assets/image-20240614004716739.png)

**某企业的邮件系统遭遇了中间人攻击。**

1. **涉及到的安全问题有哪些？**
   - **答案：**敏感信息泄露、身份伪造、数据篡改。
   - **知识点：**中间人攻击的危害
   - **复习思路：**了解中间人攻击的工作原理和影响。
2. **可能存在的安全威胁是什么？**
   - **答案：**攻击者可以拦截和篡改邮件内容，导致机密信息泄露和假冒邮件。
   - **知识点：**中间人攻击的特点
   - **复习思路：**分析中间人攻击的实施方式和潜在威胁。
3. **如何处理这样的安全事件？**
   - **答案：**使用端到端加密（如S/MIME、PGP）、部署SSL/TLS、定期更新证书、教育员工识别钓鱼邮件。
   - **知识点：**安全策略和防御措施
   - **复习思路：**复习应对中间人攻击的常见防御策略和方法。

## 第二部分 加密算法

+ 通常的加密方法使用密钥和密码算法
  + 传统加密 (也称为：对称加密): 加密和解密使用相同的密钥
  + 公钥加密 (也称为：非对称加密):加密和解密使用不同的密钥

### 对称加密

#### 传统加密算法

##### 凯撒Caesar 密码

+ 用它之后的k个来代替

##### 单表替代密码

+ 每个明文字母都被替换为另一个唯一的字母或符号。这个替换过程是通过一个固定的替换表（或密钥表）来实现的。在这种加密方法中，明文字母和密文字母之间存在一一对应的关系。

##### Playfair加密（重要）

1. 画出填充矩阵（5✖️5） 注意 i和j 放在一个格子里
	1. 密钥词（去掉重复）之后填入格子
	2. 把其他字母按顺序填入剩余的格子
2. 开始加密—— **两个字母为一组**
	1. 如果两个字母相同/字母落单了——在他们中间再加一个填充字母X/在最后一个字母后面加X
		1. balloon——ba lx lo on
	2. 同一行——用**右边**的字母代替他自己（最右边的用最左边的第一个字母代替）
	3. 同一列——用**下面**的字母代替他自己（最下面的用最上面的第一个字母代替）
	4. 其他——到对方的列去（行不变）

![截屏2024-06-14 16.33.12](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-14%2016.33.12.png)

##### 多表替代方法

Vigenere密码：在Caesar的基础上增加密钥词，密钥是一个密钥词的重复。

Vigenère密码是一种基于多表替换的加密方法，使用一个密钥对明文进行加密。加密和解密的公式如下：

###### 加密公式

给定一个明文字符 \( P_i \) 和一个密钥字符 \( K_i \)，密文字符 \( C_i \) 的计算公式为：

\[ C_i = (P_i + K_i) \mod 26 \]

其中：



- \( P_i \) 是明文字符在字母表中的位置（例如，A=0, B=1, ..., Z=25）。
- \( K_i \) 是密钥字符在字母表中的位置。
- \( C_i \) 是生成的密文字符在字母表中的位置。

###### 解密公式

给定一个密文字符 \( C_i \) 和一个密钥字符 \( K_i \)，明文字符 \( P_i \) 的计算公式为：

\[ P_i = (C_i - K_i + 26) \mod 26 \]

其中：



- \( C_i \) 是密文字符在字母表中的位置。
- \( K_i \) 是密钥字符在字母表中的位置。
- \( P_i \) 是还原的明文字符在字母表中的位置。

###### 示例

假设明文是 "HELLO" 和密钥是 "KEY"。

1. **明文和密钥对齐**：

```
明文:  H  E  L  L  O
密钥:  K  E  Y  K  E
```

2. **将字符转换为数字**（A=0, B=1, ..., Z=25）：

```
明文:  7  4  11  11  14
密钥:  10  4  24  10  4
```

3. **加密**：

```
密文:  (7+10) mod 26 = 17  (4+4) mod 26 = 8  (11+24) mod 26 = 9  (11+10) mod 26 = 21  (14+4) mod 26 = 18
       R   I   J   V   S
```

加密结果是 "RIJVS"。

4. **解密**：

将密文 "RIJVS" 和密钥 "KEY" 对齐，并将字符转换为数字：

```
密文:  17  8  9  21  18
密钥:  10  4  24  10  4
```

使用解密公式计算明文：

```
明文:  (17-10+26) mod 26 = 7  (8-4+26) mod 26 = 4  (9-24+26) mod 26 = 11  (21-10+26) mod 26 = 11  (18-4+26) mod 26 = 14
       H   E   L   L   O
```

解密结果是 "HELLO"。

###### 注意事项

1. **密钥长度**：密钥通常会重复使用，以匹配明文的长度。
2. **大写字母**：Vigenère密码通常对大写字母进行操作。对于小写字母，可以先将其转换为大写。
3. **字符范围**：公式中的所有字符都应在0到25范围内进行模运算。

缺陷：密文依旧存在循环的统计特征，

解决方案：”密钥自动生成系统“的方案——将密钥词和明文自身连接起来以便生成不重复的密钥词。

#### 现代加密算法

##### **AES（高级加密标准）**

密钥的长度可以为128（10个加密循环）、192（12）和256（14）位，也就是16个字节、24个字节和32个字节

1. **初始状态矩阵**（先排列再排行）
2. 初始化轮密钥加后的状态矩阵（异或一下）
3. 字节替代（考不来 不会考的）
4. 行移位后的状态矩阵
	1. 第一行不变
	1. 第二行向左移动一位
	1. 第三行向左移动两位
	1. 第四行向左移动三位
5. 列混淆矩阵（感觉也不会考 摆烂放弃了） 毕竟矩阵乘法还是懒得乘的

![1-2](%E5%A4%8D%E4%B9%A0.assets/1-2.png)

##### DES（数据加密标准）

密钥的长度64位，8个字节。

##### 标准的分组密码的工作模式

###### 电子密码本 (ECB-Electronic Code Book) 

+ 每一组独立做加密处理
+ ![image-20240614153232500](%E5%A4%8D%E4%B9%A0.assets/image-20240614153232500.png)
+ ![image-20240614153832363](%E5%A4%8D%E4%B9%A0.assets/image-20240614153832363.png)

###### 密码块链接 (CBC-Cipher Block Chaining) 

+ 哈希(最后一组输出就是明文的哈希值)
+ TLS/SSL用CBC做哈希

![image-20240614155408225](%E5%A4%8D%E4%B9%A0.assets/image-20240614155408225.png)

CBC模式也可以用于生成一种哈希值。这个过程可以被看作是将一个长消息压缩成一个固定长度的摘要。其工作原理如下：

1. **初始向量 (IV)**:
   
	- 选择一个初始向量 (IV)，通常为零向量或其他固定值。
   
2. **加密过程**:
   
	- 将消息分成固定大小的分组（例如128位）。
	- 第一个消息块 $M_1$ 与 IV 进行异或操作，然后加密得到第一个密文块 $C_1$：$C_1 = E_K(M_1 \oplus IV)$
	- 第二个消息块 $M_2$ 与第一个密文块 $C_1$ 进行异或操作，然后加密得到第二个密文块 $C_2$：$C_2 = E_K(M_2 \oplus C_1)$
   - 以此类推，直到处理完最后一个消息块 $M_n$：$C_n = E_K(M_n \oplus C_{n-1})$
   - 最**终的哈希值就是最后一个密文**块 $C_n$。

这种方式可以看作是一种压缩函数，但它缺乏专用哈希函数（如SHA-256）的安全特性。

总结起来，CBC模式虽然主要用于加密，但它在消息认证码（CBC-MAC）中的应用以及与哈希函数的结合使用展示了其灵活性和广泛应用的可能性。

电子密码本 (ECB - Electronic Code Book) 是一种简单的分组密码工作模式，但它有一些显著的缺点，主要包括以下几个方面：

1. **缺乏随机性**：
	- 在ECB模式下，**相同的明文块总是被加密成相同的密文块**。这意味着如果有重复的明文块，它们会在密文中表现出相同的模式，从而使攻击者可以识别这些重复块并推测出某些明文的信息。

2. **无法隐藏数据模式**：
	- 由于相同的明文块会产生相同的密文块，攻击者可以通过观察密文的模式来获取关于明文结构的信息。例如，对于图像数据来说，使用ECB模式加密后的图像仍然能够看出原始图像的大致轮廓。

3. **不具备前向和后向保密性**：
	- 如果某个密文块被破解了，它**不会影响其他密文块**的安全性。这意味着攻击者可以单独攻击每个密文块，而不需要考虑其他块的加密结果。

CBC (Cipher Block Chaining) 模式克服了ECB模式的这些缺点：

1. **引入随机性**：
	- 在CBC模式下，每个明文块在加密之前都会与前一个密文块进行异或操作。第一个明文块会与一个**初始化向量 (IV)** 进行异或操作。这意味着即使两个相同的明文块也会因为不同的前置密文块或IV而生成不同的密文块。

2. **隐藏数据模式**：
	- 由于每个明文块在加密之前都与前一个密文块进行了异或操作，这打破了明文块之间的直接联系，从而消除了密文中的模式。这样，即使是加密图像数据，密文也不会显现出原始图像的结构。

3. **增强前向和后向保密性**：
	- 在CBC模式中，每个密文块的生成不仅依赖于当前的明文块，还依赖于前一个密文块。因此，解密某个密文块需要知道前一个密文块的值。这增加了攻击者单独破解每个密文块的难度。

## **第三部分 公钥密码体系与密钥管理**（重点 计算题）

主要考**计算题** DH和RSA

+ **公钥密码体系能够提供数据认证和抗抵赖功能**
  + **身份验证**：通过私钥加密的信息可以验证消息发送者的身份。这在数字签名中非常重要，数字签名用于证明消息或文档未被篡改过，并确认发送者的身份。
  + **抗否认性**：使用私钥加密的数字签名还提供了抗否认性，意味着消息的发送者无法否认他们发送了该消息。这一点在法律和商业通信中尤为重要，因为它为交易和消息提供了一种形式的法律证明。


### 术语

+ **非对称加密**
	+ 两个密钥，用来实现互补运算，即加密和解密，或者生成签名和验证签名
+ **公钥证书**
	+ 认证机构将用户的姓名和公钥绑定在一起，用户用自己的私钥对数字文件签名后，可以通过证书识别签名者，因为签名者是唯一拥有与证书上对应的私钥的用户。
+ **公钥密码（非对称密码）算法**
	+ 含有两个密钥：公钥和私钥，从公钥推出私钥在计算上不可行
+ **公钥基础设施**（PKI）
	+ 由一系列的协议、服务平台、软件和工作站组成，用于管理证书和公钥一私钥对，并产生、维护和废除公钥证书。
+ 选择密文攻击（Chosen Ciphertext Attack，简称CCA）
	+ 是一种密码分析攻击方式，攻击者能够解密某些密文，并通过这些解密的结果，试图破解整个加密系统。
	
### 重要！PKI（Public Key Infrastructure，公钥基础设施）

+ 是一种系统和框架，用于管理、分发、存储和撤销数字证书及其公钥和私钥对。PKI的主要目标是提供安全的网络通信、身份验证、数据完整性和不可否认性。它是现代信息安全和加密技术的重要组成部分，广泛应用于电子商务、电子邮件、VPN、软件签名等领域。
+ PKI 是**使用公钥密码体系的机制**
+ PKI 负责签发、管理公钥证书
	+ 确定用户的合法性
	+ 根据用户的需求颁发公钥证书
	+ 根据用户的需求延长证书的有效期
	+ 根据用户的需求或当私钥泄露时，撤销证书
	+ 存储和管理公钥证书
	+ 防止签名者抵赖自己的签名
	+ 支持CA 中心之间实现互相认证

### 公钥密码体系的组成部分

+ **明文**：算法的输入。它们是可读信息或数据。
+ **加密算法**：加密算法对明文进行各种转换。
+ **公钥和私钥**： 算法的输入。这对密钥中一个用于加密，一个用于解密。加密算法执行的变换依赖于公钥或者私钥。
+ **密文**： 算法的输出。它依赖明文和密钥， 对给定的消息， 不同的密钥产生的密文不同。
+ **解密算法**： 该算法接收密文和相应的密钥， 并产生原始的明文。

### RSA算法（考）

RSA（Rivest-Shamir-Adleman）算法是一种广泛使用的公钥加密算法，用于安全数据传输。它基于数论中的大数分解问题，是最早实现公钥加密和数字签名的一种算法。以下是对RSA算法的详细解释，包括其原理、关键生成、加密、解密过程以及安全性。

#### RSA算法的原理

RSA算法的安全性基于大整数的质因数分解的难题，即在知道一个大整数的情况下，找到其两个质因数是计算上不可行的。

#### 密钥生成（Key Generation）

1. **选择两个大质数 \( p \) 和 \( q \)**：
	- 选择两个不同的大质数 \( p \) 和 \( q \)，它们需要足够大以保证安全性。
2. **计算 \( n \) 和 \( \phi(n) \)**：
	- \( n = p \times q \)
	- \( \phi(n) = (p-1) \times (q-1) \)
	- 其中 \( n \) 称为**模数**， \( \phi(n) \) 称为**欧拉函数**。
3. **选择公钥指数 \( e \)**：
	- 选择一个与 \( \phi(n) \) **互质**的整数 \( e \)，通常选用常见的 \( e \) 值如 3、17 或 65537，因为它们可以简化计算。
4. **计算私钥指数 \( d \)**：重要‼️
	- 计算 \( d \)，使得 \( d \equiv e^{-1} \mod \phi(n) \)，即 \( d \times e \equiv 1 \mod \phi(n) \)。
	- 这里 \( d \) 是 \( e \) 在模 \( \phi(n) \) 下的乘法逆元。
	- 例子：在使用 RSA 的公钥体制中，已截获发给某用户的密文$C=10$，该用户的公钥$e=5$,$n=35$。那么明文$M$是多少？
		- $n = p\times q$
		- 令$p=5$，$q=7$
		- $\phi(n) = (p-1) \times (q-1)=24$
		- $d \times e \equiv 1 \mod \phi(n)$
		- $d = 5$
		- $M= C^d \mod n = 100000 \mod 35 = 5$​
		- ps：其实可以直接 $ed = k\phi(n) + 1,k=0,1,2...$
5. **公钥和私钥**：
	- 公钥 \( (e, n) \)
	- 私钥 \( (d, n) \)

#### 加密过程（Encryption）

1. **将明文转换为整数 \( m \)**：
	- 将要加密的明文 \( m \) 转换为一个小于 \( n \) 的整数。
   
2. **计算密文 \( c \)**：
	- 使用公钥 \( (e, n) \) 进行加密。
	- \( c = m^e \mod n \)
   
3. **得到密文**：
	- \( c \) 即为密文。

#### 解密过程（Decryption）

1. **接收密文 \( c \)**：
	- 接收方使用私钥 \( (d, n) \) 进行解密。

2. **计算明文 \( m \)**：
	- \( m = c^d \mod n \)

3. **得到明文**：
	- \( m \) 即为解密后的明文。

#### 示例

假设选择两个质数 \( p = 61 \) 和 \( q = 53 \)：

1. **计算 \( n \) 和 \( \phi(n) \)**：
	- \( n = 61 \times 53 = 3233 \)
	- \( \phi(n) = (61-1) \times (53-1) = 3120 \)

2. **选择 \( e \)**：
	- 选择 \( e = 17 \)，它与 \( \phi(n) \) 互质。

3. **计算 \( d \)**：
	- \( d = 2753 \)（满足 \( 17 \times 2753 \equiv 1 \mod 3120 \)）

4. **公钥和私钥**：
	- 公钥：\( (17, 3233) \)
	- 私钥：\( (2753, 3233) \)

5. **加密**：
	- 将明文 \( m = 123 \) 进行加密。
	- \( c = 123^{17} \mod 3233 = 855 \)

6. **解密**：
	- 使用密文 \( c = 855 \) 进行解密。
	- \( m = 855^{2753} \mod 3233 = 123 \)

用图9.5所示的 RSA 算法对下列数据实现加密和解密

1. p=3; q=11, e=7; M=5
2. p=5: q=11, e=3: M=9
3. p=7: q=11, e 17; M=8

#### 安全性

RSA的安全性主要依赖于大整数分解的难度。具体来说，RSA的安全性基于以下几个方面：

1. **大整数分解**：
	- RSA的安全性依赖于在合理时间内无法将大整数 \( n \) 分解为两个质数 \( p \) 和 \( q \)。

2. **私钥保护**：
	- 私钥必须保密，泄露私钥将导致安全性问题。

3. **密钥长度**：
	- 密钥长度决定了RSA的安全强度。常见的密钥长度为2048位或更长，以应对未来计算能力的提升。

#### RSA公钥分发问题

RSA算法中的公钥分发涉及到如何安全地将公钥传递给需要加密数据的各方。尽管RSA是一种非常强大的加密算法，但在公钥的分发过程中仍然存在一些潜在的问题和挑战：

1. **中间人攻击（Man-in-the-Middle Attack）**
	- 在公钥分发过程中，如果攻击者能够拦截并替换公钥，就可以实施中间人攻击。**攻击者可以生成自己的公钥并将其发送给通信的双方**，从而能够**解密和篡改通信内容**。

2. **公钥伪造（Key Forgery）**
	- **没有经过验证**的公钥可能是伪造的。如果没有**可靠的机制**来验证公钥的真实性，攻击者可以伪造公钥并冒充另一个用户。
3. **公钥传输的完整性（Integrity of Key Transmission）**
	- 在公钥传输过程中，公钥的**完整性**必须得到保证。如果公钥在传输过程中被修改或损坏，将导致通信失败或安全漏洞。

4. **信任问题（Trust Issues）**
	- 如何确保接收到的公钥是可信的？这涉及到信任链的问题。如果没有一个可信的第三方机构（如证书颁发机构）来验证公钥的真实性，用户很难确定公钥是否可靠。

5. **公钥存储的安全性（Security of Public Key Storage）**
	- 即使公钥分发过程是安全的，公钥的存储也必须是安全的。存储在不安全位置的公钥可能被攻击者替换或篡改。

6. **公钥撤销（Key Revocation）**
	- 如果公钥泄露或不再可信，需要一种机制来撤销公钥。如果没有有效的公钥撤销机制，旧的公钥可能仍然被使用，从而带来安全风险。

##### 解决方案

为了应对这些问题，可以采用以下方法：

1. **使用证书和PKI（Public Key Infrastructure）**：
	- 通过**证书颁发机构（CA）**签发的数字证书来验证公钥的真实性。CA的公钥在用户设备中预先安装，从而建立信任链。
   
2. **公钥指纹验证**：
	- 在初次通信时，通过另一种安全渠道（如面对面、电话）交换公钥指纹。双方可以验证指纹是否匹配，以确保公钥未被篡改。

3. **双因素验证**：
	- 在公钥分发过程中，使用双因素验证来增加安全性。例如，要求用户在接收到公钥后通过SMS或电子邮件确认。

4. **分发公共密钥服务器**：
	- 使用可靠的公共密钥服务器（如PGP优良保密协议密钥服务器）来存储和分发公钥。这些服务器通常提供公钥验证和撤销功能。

5. **区块链技术**：
	- 使用区块链技术来存储和验证公钥，以确保公钥的不可篡改性和透明度。



### **DH密钥交换协议**（考）

Diffie-Hellman (DH) **密钥交换协议**是一种用于安全地在两个通信方之间建立共享秘密密钥的方法。DH协议本身并不是一种加密或解密算法，而是一个密钥交换机制，使得通信双方可以在不安全的信道上安全地生成共享密钥。共享密钥可以用于对称加密算法（如AES）进行加密和解密通信内容。

用于生成对称加密的共享密钥

#### 原理

DH密钥交换基于**离散对数**问题的难解性。具体步骤如下：

1. **公开参数**：
	- 选择一个大素数 \( p \) 和一个基数 \( g \)，其中 \( g \) 是 \( p \) 的一个本原根。这些参数可以公开。

2. **密钥生成**：
	- 每个参与者选择一个秘密私钥（私有数），通常称为 \( a \) 和 \( b \)。

3. **计算部分密钥**：
	- 每个参与者根据自己的私钥和基数计算出一个部分密钥，并将其公开。
	- 计算公式：
		- Alice 计算 \( A = g^a \mod p \) 并将 \( A \) 发送给 Bob。
		- Bob 计算 \( B = g^b \mod p \) 并将 \( B \) 发送给 Alice。

4. **计算共享密钥**：
	- 每个参与者使用对方的部分密钥和自己的私钥计算出共享密钥。
	- 计算公式：
		- Alice 计算共享密钥 \( s = B^a \mod p \)。
		- Bob 计算共享密钥 \( s = A^b \mod p \)。
	- 由于 \( B = g^b \) 和 \( A = g^a \)，共享密钥 \( s \) 的值相同：
		- \( s = (g^b)^a \mod p = (g^a)^b \mod p \)。

这个共享密钥可以用于对称加密算法，例如AES，用于加密和解密通信内容。

#### 示例

假设选择素数 \( p = 23 \) 和基数 \( g = 5 \)。


- **Alice 和 Bob 选择私钥**：
	- Alice 选择私钥 \( a = 6 \)。
	- Bob 选择私钥 \( b = 15 \)。

- **计算部分密钥**：
	- Alice 计算 \( A = 5^6 \mod 23 = 8 \) 并将 \( A \) 发送给 Bob。
	- Bob 计算 \( B = 5^15 \mod 23 = 19 \) 并将 \( B \) 发送给 Alice。

- **计算共享密钥**：
	- Alice 计算共享密钥 \( s = 19^6 \mod 23 = 2 \)。
	- Bob 计算共享密钥 \( s = 8^15 \mod 23 = 2 \)。

因此，Alice 和 Bob 共享的秘密密钥是 2。

![截屏2024-06-28 22.55.27](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-28%2022.55.27.png)

![截屏2024-06-28 22.55.40](%E5%A4%8D%E4%B9%A0.assets/%E6%88%AA%E5%B1%8F2024-06-28%2022.55.40.png)

#### 安全性

DH密钥交换协议的安全性依赖于离散对数问题的难解性。即使攻击者知道 \( p \)、\( g \)、\( A \) 和 \( B \)，计算出 \( s \) 仍然是计算上不可行的。

#### 实际应用

DH密钥交换协议广泛用于各种安全通信协议中，例如：

- **TLS/SSL**：用于保护互联网通信的安全。
- **IPsec**：用于保护IP网络层的安全。
- **SSH**：用于保护远程登录的安全。

#### 变体

DH密钥交换协议有多种变体，包括：

- **椭圆曲线Diffie-Hellman（ECDH）**：基于椭圆曲线离散对数问题，提供更高的安全性和效率。
- **静态DH和临时DH**：在一些协议中，密钥交换的双方可能会在多个会话中重复使用相同的私钥（静态DH）或每次会话生成新的私钥（临时DH）。

## 第四部分 密码学中的数据完整性算法 

MD5（Message Digest Algorithm 5）和SHA（Secure Hash Algorithm）都是常用的哈希算法，用于生成固定长度的散列值（哈希值）来表示任意长度的数据。它们在**数据完整性**校验、数字签名和密码学应用中非常重要。下面是对MD5和SHA的详细解释。

### MD5（Message Digest Algorithm 5消息摘要算法第五版）

#### 概念
- **MD5**是一种广泛使用的哈希函数，产生**128位（16字节）**的哈希值。
- 由罗纳德·李维斯特（Ronald Rivest）设计，于1991年发布。

#### 特点
- **固定长度输出**：无论输入数据长度如何，MD5都会生成一个128位的哈希值。
- **快速计算**：MD5算法设计用于快速生成哈希值。
- **抗碰撞性**：理论上不同输入不应生成相同的哈希值（碰撞），但MD5的抗碰撞性已经被破解。

#### 工作原理
MD5将输入数据分块处理，每块512位，填充至512位的整数倍。然后通过一系列的非线性函数和位运算，生成128位的输出。

#### 具体步骤
1. **填充数据**：将输入数据填充至长度为448位的倍数（即填充至512位的整数倍），填充值包括一个1和若干个0。
2. **附加长度**：在填充后的数据末尾附加64位，表示原始数据长度。
3. **初始化变量**：初始化四个32位的寄存器A、B、C、D。
4. **处理每个块**：对每个512位的数据块进行一系列复杂的操作，包括位操作、逻辑运算和非线性函数。
5. **输出结果**：将四个寄存器A、B、C、D的值连接起来，生成128位的哈希值。

#### 安全性
- **碰撞攻击**：2004年，研究人员发现了MD5的碰撞攻击方法，即找到不同的输入数据使其生成相同的哈希值。
- **不推荐使用**：由于安全性问题，MD5不再推荐用于安全敏感的应用。

### SHA（Secure Hash Algorithm安全散列算法）

#### 概念
- **SHA**是一系列由美国国家安全局（NSA）设计并由国家标准与技术研究院（NIST）发布的哈希函数家族。
- 包括SHA-0、SHA-1、SHA-2、SHA-3等版本。

#### SHA-1
- **SHA-1**产生160位（20字节）的哈希值。
- 发布于1993年，被认为不再安全。

#### SHA-2
- **SHA-2**家族包括SHA-224、SHA-256、SHA-384、SHA-512等，数字表示生成哈希值的位数。
- 例如，SHA-256产生256位（32字节）的哈希值。
- 目前仍被广泛使用。

#### SHA-3
- **SHA-3**是一种替代性的哈希算法，与SHA-2结构不同，由Keccak算法设计。
- 提供类似的安全性和不同的内部结构。

#### 工作原理（以SHA-256为例）
1. **填充数据**：将输入数据填充至长度为448位的倍数（即填充至512位的整数倍），填充值包括一个1和若干个0。
2. **附加长度**：在填充后的数据末尾附加64位，表示原始数据长度。
3. **初始化变量**：初始化八个32位的寄存器H0-H7。
4. **处理每个块**：对每个512位的数据块进行64轮的处理，每轮包括位操作、逻辑运算和非线性函数。
5. **输出结果**：将八个寄存器H0-H7的值连接起来，生成256位的哈希值。

#### 安全性
- **抗碰撞性**：SHA-256及以上的SHA-2变种目前被认为具有良好的抗碰撞性和抗攻击性。
- **广泛使用**：SHA-256是当前密码学应用中的标准选择，包括数字签名、证书和区块链。

### MD5和SHA对比
- **哈希长度**：MD5生成128位哈希值，而SHA-1生成160位，SHA-256生成256位。
- **安全性**：MD5和SHA-1已被证明不安全，不推荐使用。SHA-2（特别是SHA-256）和SHA-3仍被广泛认为是安全的。
- **应用场景**：MD5适用于非安全性场景（如文件校验），SHA-256和SHA-3适用于安全性要求高的场景（如加密、签名）。



### 数字指纹

+ **不需要使用**秘密密钥而生成的一个长数据的**短的表示**，称为数字摘要或数字指纹
+ 数字指纹可以使用密码散列函数得到，又称为**单向散列函数**

#### 消息认证码 (MAC)

+ **使用**秘密密钥产生的数据的**短**表示，称为**消息认证码 (MAC)**或标签

+ MAC 可以通过加密的校验和算法得到
+ 带密钥的散列消息认证码(*HMAC*) 是密码散列函数和密码校验和算法的组合

![image-20240629204710521](%E5%A4%8D%E4%B9%A0.assets/image-20240629204710521.png)

#### 密码校验和

+ 校验和通常用于检测网络通信中的传输错误
  + 但是，这些校验和不能用于数据认证或数字指纹，因为很容易找到不同的消息具有相同的校验和
  + l我们可以用对称密码算法生成密码校验和，用于数据认证
+ 密码校验和又称为消息认证码 (MAC)

### 密码散列函数

+ 散列函数以一个长的消息为输入，分成若干部分后，进行“打碎重组”，产生一个新的短字符串。

#### 重要‼️密码散列函数的设计要求——单向性、计算唯一性（无碰撞性、强无碰撞性）

+ 设 $H$表示一个散列函数, $Γ$ 是输入长度的上界, $γ$ 是比$Γ$小得多的固定的输出长度
+ **单向性**: 计算一个给定消息串的数字指纹是容易的, 但是找到一个数字指纹对应的消息是困难的
  + 对于任意的二进制串*x* ，其中 $|x| ≤ Γ$, 计算 $H(x)$是容易的, 但是对于一个给定的散列值 $h ( |h| = γ)$, 很难找到它对应的原像$x$使得$h = H(x)$​
+ **计算唯一性**: 找到两个不同的消息具有相同的数字指纹是困难的
  + 无碰撞性
    + 给定一个消息 $x$，满足$|x| ≤ Γ$, 找到另一个不同的消息$y (|y| ≤ Γ)$与$x$具有相同的散列值，即$H(x) = H(y)$，是困难的
  + **强**无碰撞性
    + **很难**找到两个消息$x$和$y$具有相同的散列，即$H(x) = H(y)$
  + 注意：不满足强无碰撞性，并不意味着不满足无碰撞性

#### 单项散列函数无法解决的问题

+ 单向散列函数可以实现**完整性检测**
+ 但很多情况下仅仅能够检测完整性是不够的
+ 不仅要确认完整性，还需要确认来源（也即**认证**）
+ 用于认证的技术包括
  + 消息认证码：能够向通信对象保证消息没有被篡改
  + 数字签名：不仅能向通信对象保证消息没有被篡改，还能向所有第三方做出这样的保证。（公钥技术）

### **数字签名标准** **(DSS)**

+ 只生成数字签名, 不加密数据

### **双签名与电子交易**

+ 双签名是一种用于**电子交易**的交互式认证协议
  + 提供安全和隐私性保护
  + 在SET协议 (Secure Electronic Transactions)中使用, 此协议是由Visa 和 MasterCard 在1996年设计的，但是没有在实际中推广需要 
+ Alice, Bob和Charlie 协商确定使用的散列函数$H$ 和公钥加密算法$E$
+ Alice, Bob和Charlie 必须各自有一对RSA密钥对: $(K_A^u, K_A^r)$, $(K_B^u, K_B^r)$, $(K_C^u, K_C^r)$

![image-20240616200531039](%E5%A4%8D%E4%B9%A0.assets/image-20240616200531039.png)

![image-20240616200908961](%E5%A4%8D%E4%B9%A0.assets/image-20240616200908961.png)

双签名协议是一种用于确保电子交易双方（买方和卖方）在安全的电子支付系统中**都无法单独篡改交**易信息的机制。这个协议主要用于确保交易的**完整性和真实性**，并**防止交易中的任何一方否认交易**。下面是对双签名协议的详细解释：

#### 双签名协议的基本概念

在双签名协议中，涉及三方：买方、卖方和银行。协议通过以下步骤实现：

1. **买方签名**：买方使用自己的私钥对交易信息进行签名，生成买方签名。
2. **卖方签名**：卖方使用自己的私钥对交易信息进行签名，生成卖方签名。
3. **双签名**：将买方签名和卖方签名组合在一起，形成一个完整的双签名。

#### 双签名协议的工作流程

1. **买方创建交易信息**：买方生成一条包含交易金额、商品信息等的交易信息（消息）。
2. **买方签名**：买方使用自己的私钥对交易信息进行签名，生成买方签名。
3. **买方将签名的交易信息发送给卖方**：买方将签名的交易信息发送给卖方。
4. **卖方验证买方签名**：卖方使用买方的公钥验证买方签名的真实性。
5. **卖方签名**：验证通过后，卖方使用自己的私钥对交易信息进行签名，生成卖方签名。
6. **卖方将双签名的交易信息发送给银行**：卖方将包含买方签名和卖方签名的交易信息发送给银行。
7. **银行验证签名**：银行使用买方和卖方的公钥分别验证双签名的真实性。
8. **银行处理交易**：验证通过后，银行处理交易（如资金转移）。

#### 双签名协议的优点

1. **防篡改**：由于交易信息需要买方和卖方的双重签名，任何一方都无法单独篡改交易信息。
2. **防抵赖**：买方和卖方的签名都可以作为证据，防止任何一方事后否认交易。
3. **完整性**：确保交易信息在传输过程中未被篡改。
4. **身份认证**：签名过程确保了交易双方的身份认证。

#### 双签名协议的示例

假设买方 Alice 和卖方 Bob 进行一笔电子交易，交易金额为 $100。

1. **买方创建交易信息**：
   - 交易信息：`{amount: 100, buyer: Alice, seller: Bob}`
2. **买方签名**：
   - 买方私钥签名交易信息，生成买方签名：`sign_buyer = Sign(PrivateKey_Alice, transaction)`
3. **买方将签名的交易信息发送给卖方**：
   - 买方发送 `{transaction, sign_buyer}` 给卖方。
4. **卖方验证买方签名**：
   - 卖方使用买方的公钥验证买方签名：`Verify(PublicKey_Alice, transaction, sign_buyer)`
5. **卖方签名**：
   - 验证通过后，卖方私钥签名交易信息，生成卖方签名：`sign_seller = Sign(PrivateKey_Bob, transaction)`
6. **卖方将双签名的交易信息发送给银行**：
   - 卖方发送 `{transaction, sign_buyer, sign_seller}` 给银行。
7. **银行验证签名**：
   - 银行使用买方和卖方的公钥分别验证签名：
     - `Verify(PublicKey_Alice, transaction, sign_buyer)`
     - `Verify(PublicKey_Bob, transaction, sign_seller)`
8. **银行处理交易**：
   - 验证通过后，银行处理交易，转移 $100 从 Alice 的账户到 Bob 的账户。

### 小结

![image-20240616202040474](%E5%A4%8D%E4%B9%A0.assets/image-20240616202040474.png)

## 第五部分 互信

两个通信方之间分发密钥的方法。

### 基于对称加密的对称密钥分发

### 基于对称加密的对称密钥分发

### 用户认证

#### Kerberos（判断题）

Kerberos 通过提供**一个集中的授权服务器来负责用户对服务器的认证和服务器对用户的认证**，而不是为每个服务器提供详细的认证协议。与本书中其他认证方案不同的是， Kerberos 仅仅依赖于**对称**加密体制而没有使用公钥加密体制。

+ 说人话就是用户与服务之间的认证，比如你去买票要身份证验证是你本人。

## 第六部分 网络与Internet安全

### 不同层次实施安全协议的优缺点

#### 应用层 —— S/MIME, PGP, PEM, SET, Kerberos, SHTTP, SSH

+ 提供**端对端**安全保护
+ **不需要**解密数据或验证签名
+ 攻击者能**够分析流量以及修改报头**

#### 传输层 —— SSL / TLS（传输层之上，应用层之下，但也算传输层协议）

+ 提供**TCP包**的安全保护
+ **不需要**修改应用程序
+ 攻击者**可以通过IP包头分析网络流量**

#### 网络层 —— IP 安全性(IPSec)

+ 提供**链对链**的安全保护
	+ **传输模式**: 只加密载荷
	+ **隧道模式**: 加密包头和载荷，需要**网关**
+ 不需要修改任何应用程序

#### 数据链路层

+ 提供数据帧的安全保护
+ 不需要修改任何应用程序
+ 流量分析**不会泄露太多信息**

### 证书——解决数字签名无法直接解决的问题

+ 数字签名可以实现消息完整性的确认、身份认证以及防止否认。
+ 但前提是，用于验证签名的公钥必须属于真正的发送者。如果所得到的公钥是伪造的，那么数字签名也会完全失效。
+ 为了能够确认自己得到的公钥是否合法，需要使用**证书**。
+ 证书：就是将公钥作为一条消息，由一个可信的第三方对其进行签名（第三方的私钥）后所得到的公钥。

![image-20240616204436230](%E5%A4%8D%E4%B9%A0.assets/image-20240616204436230.png)



### 重要！IPsec（Internet Protocol Security IP 安全性 互联网协议安全）

**IPsec**是一组协议，用于在互联网上通过加密和验证确保IP包的机密性、完整性和真实性。IPsec工作在网络层，可以保护所有通过IP传输的数据。

+ IPsec是网络层的协议

+ IPsec 实现对IP包的加密和认证，包括3个协议:
  + **认证头协议(AH)**Authentication Header
    + 认证IP包的来源和完整性
    + 用**滑动窗口**防御消息重放攻击
  + **封装安全载荷协议(ESP)** Encapsulating Security Payload
    + 加密和认证IP包
  + **互联网密钥交换协议(IKE)**Internet Key Exchange
    + 用于通信双方协商密钥
    + 加密和认证都要求通信双方拥有共同密钥
    + 手工和自动（IKE)
    + IKE
    	+ Oakley密钥确定协议（DH+身份认证）
    	+ ISAKMP密钥管理协议（互联网安全联盟和密钥管理协议）（只规定了交换格式，未规定密钥交换算法）

+ 两种运行模式
	+ 传输模式（主要用于端到端通信，如客户端和服务器之间的，保护的是传输层协议（TCP/UDP）的数据部分，不包括IP头）
	+ 隧道模式(需要网关，主要用于网关到网关，主机到网关，网关到主机的通信，加密/认证整个IP数据包，并封装在一个新的数据包中，添加新的IP头)‏

![image-20240616210045390](%E5%A4%8D%E4%B9%A0.assets/image-20240616210045390.png)

+ IPsec通过**AH和ESP为IP数据报**文提供安全服务
	+ 不同的用户可能需要不同的安全服务
	+ 同一用户不同的数据也有可能需要提供不同的安全服务。
	+ 比如在一个公司里，有一个集中的管理部门，其内部的通信必须保证信息的完整性，但不需要加密；而管理部门和其他部门之间的通信则即需要保证信息完整性，又必须保证机密性。

+ IPsec可以通过两种协议来实现安全性：AH（Authentication Header）和ESP（Encapsulating Security Payload）。

  + **AH（Authentication Header）**认证头：

    - 提供数据完整性和身份验证。

    - 不提供数据加密。

    - AH头部插入在IP头部和传输层协议（如TCP/UDP）头部之间。

  + **ESP（Encapsulating Security Payload）** 封装安全载荷：

    - 提供数据加密、完整性和身份验证。

    - ESP头部插入在IP头部和传输层协议头部之间。

    - ESP尾部和认证数据附加在IP包末尾。

#### IPsec的主要功能

1. **数据加密**：使用对称加密算法（如AES、3DES）对IP包进行加密，确保数据的机密性。
2. **数据完整性和验证**：使用哈希算法（如SHA-256）和密钥认证码（HMAC）确保数据的完整性和真实性。
3. **密钥交换**：使用Internet Key Exchange（IKE）协议进行密钥协商和管理，确保密钥的安全交换。
4. **隧道模式和传输模式**：IPsec有两种工作模式：
	- **隧道模式**：整个IP包被加密并封装在一个新的IP包中，通常用于VPN（虚拟专用网络）。
	- **传输模式**：仅加密IP包的有效负载，保留原始IP头部，通常用于端到端的通信保护。

#### IPsec包的结构

![image-20240616205005981](%E5%A4%8D%E4%B9%A0.assets/image-20240616205005981.png)

### 重要！IPsec 包的组成

+ 传输模式： IP头+IPsec头+数据
+ 隧道模式IP网关+ IPsec头+IP头+数据



![image-20240616211526768](%E5%A4%8D%E4%B9%A0.assets/image-20240616211526768.png)

![image-20240616211539571](%E5%A4%8D%E4%B9%A0.assets/image-20240616211539571.png)

![image-20240616211602344](%E5%A4%8D%E4%B9%A0.assets/image-20240616211602344.png)


### 安全策略

+ **安全策略数据库（SPD）**
	+ 库中的每条记录对应一个安全策略
+ 对我的所有访问都要进行身份验证 $\to$ 对目的地址为192.168.0.1的通信都要通过HMAC-SHA进行身份验证
+ 对于外出的数据报文，必须先检索SPD（决定提供给它什么样的安全服务）
+ 对于进入的数据报文，也要检索SPD，判断为该报文提供的安全服务是否和本地安全策略所规定的安全服务相符。

#### 安全策略的要素

+ 目的IP、源IP、传输层协议、源和目的端口等
+ 处理方式：丢弃、绕过、应用IPsec
+ 如果是**应用IPsec**，策略要包含使用的**安全协议（AH/ESP）、模式（传输/隧道）、算法（加密-认证）**等，这些参数以安全关联的形式存在**安全关联数据库中（SAD**）。

### 安全联盟(SA)

![image-20240616210946230](%E5%A4%8D%E4%B9%A0.assets/image-20240616210946230.png)

+ 当 Alice 要与Bob 建立 IPsec 连接, 双方首先需要协商使用的算法和密钥
+ 安全联盟就是为实现以上目的
+ 一个安全联盟(SA)在通信的发起者和响应者之间建立，在一个会话阶段内有效
+ **一个安全联盟(SA) 可以用于加密或者认证，但不能同时用于两者**
+ 如果一个连接既需要加密又需要认证，则需要**建立两个安全联结(SA)**，一个用于加密，另一个用于认证



#### 安全联盟的组成

+ 三个参数:
	+ 安全参数索引(SPI)Security Parameter Index
	+ 目标IP 地址
	+ 安全协议标识符

+ 安全联盟数据库(SAD) Security Association Database
	+ 在本地主机上存储安全联盟
+ 安全策略数据库(SPD) Security Policy Database
	+ 一组对IP包进行加密或认证的策略
+ SA 选择器(SAS) 安全联盟选择器 (Security Association Selectors, SAS)
	+ 指定每个安全联盟用于哪些IP包的规则


### 阻塞攻击

+ 一种拒绝服务攻击
+ 攻击者在欺诈的IP包中发送大量的公钥$Y_i$ , 使得被攻击主机忙于进行大量的计算秘密密钥的运算$K_i = Y_iX \mod p$
	+ Diffie-Hellman密钥交换协议中的模幂运算是非常耗时的
+ **Cookies技术**
	+ 在计算之前, 接收方向发起方发送一个cookie (随机数)，并等待发起方发回包含此cookie的确认信息
	+ 这可以防止攻击者通过修改源IP地址来伪造大量的DH请求包



### **SSL安全套接字层/TLS传输层安全协议**

+ 用于保护 WWW 应用和电子交易
+ 用CBC密码块链接做哈希
+ SSL/TLS在传输层协议（如TCP）之上运行，为**应用层协议（如HTTP、SMTP、IMAP等）提供安全保障**。它通过加密、认证和完整性校验等手段，确保数据在**传输过程**中不被窃取、篡改或伪造。
+ Transport layer security protocol (TLS)
  + SSLv3修订版本

+ 两个主要组成部分:
  + **记录协议**：在传输层协议的上方
  + **握手协议、密码更换协议、提醒协议**：位于应用层协议和记录协议之间

+ TLS（Transport Layer Security，传输层安全协议）是一种用于在计算机网络上提供通信安全性的协议。TLS广泛应用于互联网通信中，用于保护数据传输的安全性和隐私性。它是**SSL（Secure Sockets Layer，安全套接字层）**的继任者。

![image-20240629203739746](%E5%A4%8D%E4%B9%A0.assets/image-20240629203739746.png)

#### SSL记录协议（‼️）

SSL（Secure Sockets Layer）记录协议是SSL/TLS协议栈中的核心部分，负责对应用数据进行分片、压缩、加密和完整性保护。下面是SSL记录协议的结构及其主要功能的详细阐述：

##### SSL记录协议的主要功能

1. **分片（Fragmentation）**：将应用数据分成合适大小的块，每个块称为一个记录。
2. **压缩（Compression）**：对数据进行压缩（可选），以减少数据传输的大小。
3. **加密（Encryption）**：使用对称密钥对数据进行加密，确保数据的保密性。
4. **消息认证码（MAC，Message Authentication Code）**：计算数据的MAC值，以确保数据的完整性和真实性。

##### SSL记录协议的工作流程（简答题！！）

1. **分片**：将大块的应用数据分成多个小记录，每个记录的大小受限于协议规定的最大长度。
2. **压缩**：对记录进行压缩以减少数据大小（如果协商使用压缩）。
3. **认证**：为记录计算消息认证码（MAC），确保数据在传输过程中未被篡改。
4. **加密**：使用协商好的对称密钥对记录进行加密，确保数据的保密性。
5. **加头**：给每个块加上SSL头
6. **发送**：将加密后的记录通过传输层（通常是TCP）发送到接收方。

接收方在收到记录后，会按以下步骤处理：

1. **解密**：使用对称密钥解密记录。
2. **验证MAC**：计算消息认证码并与记录中的MAC进行比对，确保数据未被篡改。
3. **解压缩**：如果使用了压缩，对记录进行解压缩。
4. **重组**：将多个记录重组为原始的应用数据。

通过这些步骤，SSL记录协议确保了数据在传输过程中的机密性、完整性和真实性。

### 基本的电子邮件安全机制

![image-20240629210652439](%E5%A4%8D%E4%B9%A0.assets/image-20240629210652439.png)

1. **哈希保证完整性**
	- **哈希函数 (H)**：用于计算消息 \( M \) 的哈希值 \( H(M) \)，生成一个固定长度的摘要。
	- 目的是确保消息在传输过程中未被篡改。即使消息有一点点改变，哈希值也会有很大的变化。

2. **私钥做签名**
	- 使用发送者 \( A \) 的私钥对哈希值 \( H(M) \) 进行加密，生成数字签名。
	- 数字签名证明了消息的来源和完整性，接收者可以通过发送者的公钥验证签名的有效性。

3. **用公钥验证（附在后面，让其他人做验证）**
	- **验证签名 **：接收者 \( B \) 使用发送者 \( A \) 的公钥解密签名，验证解密后的哈希值是否与消息计算的哈希值一致，以确认消息的完整性和来源。

4. **对称加密 保密性**
	- **对称加密 **：发送者 \( A \) 使用对称密钥 加密消息 \( M \)，确保消息内容的保密性。
	- **密钥交换**：发送者 \( A \) 使用接收者 \( B \) 的公钥加密对称密钥，确保密钥的保密性。

5. **证书颁发机构 (CA)**
	- 用来验证发送者的公钥的真实性，由受信任的第三方（证书颁发机构，CA）签发。

### PGP（Pretty Good Privacy 优良保密协议）

+ **PGP**是一种数据加密和解密的计算机程序，提供加密和签名功能，主要用于保护**电子邮件通信**的隐私和验证电子邮件内容的完整性和发送者身份。它结合了对称密钥加密和非对称密钥加密的优点。

#### PGP的主要功能

1. **数据加密**：使用对称密钥算法（如AES）加密消息内容，确保消息的机密性。
2. **密钥加密**：对称密钥使用接收者的公钥加密，确保只有接收者能够解密。
3. **数字签名**：使用发送者的私钥对消息进行签名，接收者可以使用发送者的公钥验证消息的真实性和完整性。
4. **密钥管理**：PGP使用密钥环（keyring）管理公钥和私钥，支持多用户环境下的密钥交换和管理。



### 无线网络安全

#### WEP（重要）有线等价隐私协议

+ WEP（Wired Equivalent Privacy）是第一个用于无线网络的安全协议，旨在提供与有线网络相同的安全级别。

**特性：**

1. **加密算法：** WEP使用RC4流加密算法来加密数据。
2. **密钥长度：** 常用的密钥长度有40位和104位，加上24位的初始化向量（IV），总长度为64位或128位。
3. **认证方式：** 采用**静态密钥**，所有客户端和接入点使用相同的密钥。
4. **数据完整性：** 使用CRC-32校验码来验证数据完整性。

##### 缺陷和问题（简答题‼️）

###### **认证缺陷**

由于WEP采用的**挑战-应答机制**是一个简单的**异或运算**，因此很容易受到明文攻击

- **拦截通信**：攻击者在合法的AP（接入点）和STA（站点）之间恶意拦截挑战-应答信息对（`cha`, `res`）。
- **计算密钥流**：攻击者可以通过以下方式计算密钥流：$k_i = c_i \oplus r_i \quad \text{for } i = 1,2,…,16$
  其中，`c_i`是挑战信息，`r_i`是应答信息，`k_i`是密钥流的每一位。
- **发送连接请求**：攻击者向AP发送连接请求，并等待其发出的新的挑战信息`cha'`。
- **生成应答信息**：攻击者利用之前计算的密钥流和新的挑战信息进行运算，生成一个新的应答信息`res'`。然后，攻击者将此信息和截获的初始化向量（IV）一起发送给AP。
- **认证绕过**：基于WEP协议，AP对收到的IV和密钥应用RC4算法，生成密钥流`k_1, k_2, k_3,… k_16`。然后AP验证：$k_i \oplus res' = cha'$
  如果验证通过，AP认为攻击者的设备是合法设备，并允许其连接到网络。

###### **完整性校验缺陷**

WEP使用**CRC（循环冗余校验）**进行数据完整性检查，但CRC的**线性特性**使其容易受到篡改和伪造攻击。

- **CRC的线性运算性质**：CRC的计算具有线性特征，即：$\text{CRC}(x \oplus y) = \text{CRC}(x) \oplus \text{CRC}(y)$
  这意味着攻击者可以通过对数据包进行特定的修改，保持CRC值不变，从而绕过数据完整性检查。
- **无密钥的CRC**：**CRC计算不涉及任何密钥**，这使得攻击者可以轻松向网络注入伪造的数据包，而不被检测到。
  - **篡改数据**：攻击者可以修改现有数据包的内容，并重新计算CRC值，**使其与修改后的数据匹配**。
  - **注入信息**：攻击者可以创建新的伪造数据包，并计算其CRC值，然后将其注入网络。
  - **碎片攻击**：攻击者可以将数据包分成多个片段，篡改其中的某些片段，并利用CRC的线性特性进行重新组合，绕过数据完整性检查。

###### **初始化向量（IV）问题**

- **IV长度过短：** WEP使用24位的初始化向量（IV）。由于IV的长度有限，在高流量的网络中，IV会重复使用。这使得攻击者可以捕获足够多的数据包后，通过分析重复的IV，推断出密钥。
- **IV明文传输：** IV以明文形式传输，攻击者可以轻易地获取并分析IV，进一步增加了攻击的可能性。

###### **密钥管理问题**

- **静态密钥：** WEP使用的加密密钥是**静态**的，所有设备**共享同一个密钥**。这意味着一旦一个密钥被破解，整个网络的安全性就会被破坏。
- **密钥更新困难：** 更改密钥需要**手动**操作，且**所有设备都需要同步更新密钥**，增加了管理难度和安全风险。

#### WPA Wi-Fi Protected Access Wi-Fi保护访问（全称重要）

+ WPA（Wi-Fi Protected Access）是为解决WEP安全问题而推出的增强安全协议。
+ 三个主要目的:
	+ 纠正所有已经发现的WEP中的安全弱点
	+ 确保现有WEP硬件也同样能支持WPA 
	+ 确保WPA与802.11i标准兼容
+ 采用 802.1X 协议认证用户设备
+ Temporal Key Integrity Protocol (TKIP):
	+ 用 *Michael*算法，一种特殊设计的完整性检查算法 
	+ 用一种**新的密钥结构**防止旧信重放并使之**无法从RC4 密钥获取公有初始向量**  
+ **特性：**
	1. **加密算法：** 使用**TKIP（临时密钥完整性协议）**作为过渡方案，后续版本（WPA2）引入了更强的AES（高级加密标准）加密算法。
	2. **密钥管理：** 动态生成加密密钥，避免了静态密钥的安全问题。
	3. 认证方式：
		- **WPA-PSK（预共享密钥模式）：** 适用于家庭和小型网络，使用共享密码进行认证。
		- **WPA-Enterprise（企业模式）：** 适用于企业网络，通过802.1X标准和RADIUS服务器进行认证。
	4. **数据完整性：** 使用Michael算法进行数据完整性校验，防止数据被篡改。



## 第七部分 防火墙

+ 防火墙是什么?
	+ 一个硬件设备, 一种软件,或者两者结合
	+ 是Internet和网络边缘的一个界线(内部网络)
	+ 一种过滤流入和外发分组的机制.
	+ 可能是硬件和(或)软件
		+ 硬件快但是升级不方便
		+ 软件慢但便于升级

### 防火墙的类型



### 防火墙的配置（大概率不考）

#### **单界面堡垒系统**

+ 由一个分组过滤路由器和一个堡垒主机组成
	+ 路由器用于连接内部和外部网络
	+ 堡垒主机在内部网络
+ 分组过滤防火墙（PF firewall）检查每个外发分组，如果其源地址不是堡垒主机的IP地址，则将其阻挡
+ 如果分组过滤路由器受到损害，攻击者可能修改ACL并绕过堡垒主机

![image-20240629223428435](%E5%A4%8D%E4%B9%A0.assets/image-20240629223428435.png)

#### **双界面堡垒系统**

+ 在内部网络中有两个区域:
	+ 内区: 从外部不可访问
	+ 外区: 来自Internet的主机可以访问
+ 内区的主机受到堡垒主机和分组过滤路由器的双重保护
+ 外区的服务器分组过滤路由器保护
+ 即使分组过滤路由器受损也能阻止外部对内部网络的访问

![image-20240629223434974](%E5%A4%8D%E4%B9%A0.assets/image-20240629223434974.png)

#### **子网监控防火墙系统**

+ 一个单界面堡垒系统网络为内部网络配备一个二级分组过滤路由器
+ 两个分组过滤路由器之间的区域被称一个监控子网
+ 将内部网络结构隐藏起来

![image-20240629223450016](%E5%A4%8D%E4%B9%A0.assets/image-20240629223450016.png)

### ‼️必考-防火墙技术（优缺点）

![image-20240629223608002](%E5%A4%8D%E4%B9%A0.assets/image-20240629223608002.png)

1. **Packet Filtering（分组过滤）**
	- **网络层（Network Layer）**：在IP层工作，主要检查数据包的IP头部信息以及TCP/UDP的端口号，不关心数据包的内容。
	- **工作机制**：
		- 通过访问控制列表（ACL）定义的规则集，允许或拒绝数据包。
		- 可以执行无状态或有状态的过滤。
	- **优点**：性能高，处理速度快，透明性好。
	- **缺点**：安全性较低，灵活性差，难以检测应用层攻击。

2. **Circuit Gateway（电路网关）**
	- **运输层（Transport Layer）**：在TCP/UDP层工作，通过检查TCP/UDP段的IP地址和端口号信息来确定连接是否合法。
	- **工作机制**：
		- 在内部主机和外部主机之间建立一个TCP中继连接，不允许直接连接。
		- 维护一个有效连接表，检查流入的数据包是否符合连接规则。
	- **优点**：提供中等性能和安全性，适用于需要中等程度控制的场景。
	- **缺点**：对内存和CPU资源有一定消耗，配置较复杂。

3. **Application Gateway（应用网关）**
	- **应用层（Application Layer）**：在应用层工作，处理来自外部客户端的服务请求，代理内部主机。
	- **工作机制**：
		- 对所有数据包进行深度检查，检查应用程序格式，基于负载应用规则。
		- 能够检测恶意和可疑的数据包，提供更强的安全保障。
	- **优点**：提供最高的安全性，细粒度控制，能够检测应用层攻击。
	- **缺点**：处理速度慢，对网络性能影响较大，配置复杂，对资源需求高。

---

#### 分组过滤

+ 执行分组进入和外出的过滤
+ 仅监视IP和TCP/UDP的头部, 不考虑负载
+ 既可以执行无状态的也可以执行有状态的过滤
	+ 无状态的过滤: 容易实现但非常简单
		+ 执行“哑的”过滤
			+ 应用静态规则集来监视每个分组
			+ 不保留之前分组的结果
		+ 所用规则集称为访问控制列表 (ACL)
			+ 自顶向下的匹配规则，应用匹配到的第一个规则
			+ 如果没有匹配的规则,则按照缺省规则过滤
	+ 有状态的过滤: 较难实现但功能强大
		+ 比无状态的过滤智能
			+ 保持对内部和外部主机连接的跟踪
			+ 仅接受/拒绝基于连接状态的分组
			+ 通常和无状态的过滤组合使用
		+ 必须关注内存和CPU的时间需求; 连接跟踪是非常耗费资源的!

**优点：**

1. **高效性能**：只检查数据包的IP和TCP/UDP头部信息，不考虑负载，处理速度快，对网络性能影响小。
2. **简单实现**：无状态过滤容易实现，配置和管理相对简单。
3. **透明性**：用户无感知，不需要客户端配置额外的软件或代理。

**缺点：**

1. **安全性较低**：无状态过滤只能根据静态规则集进行过滤，无法检测基于应用层的攻击，如SQL注入、XSS等。
2. **灵活性差**：规则集相对简单，难以实现复杂的安全策略。
3. **资源消耗**：有状态过滤需要维护连接状态，对内存和CPU资源需求较高。

---

#### 电路网关

+ 运行在运输层
+ 审查TCP/UDP段的IP地址信息和端口号信息来确定该连接是否合法
+ 在应用中，通常讲分组过滤和电路网关结合起来
+ 基本结构：
	+ 在一个内部主机和外部主机形成一个TCP中继连接
	+ 不允许内外部网络直接连接
	+ 对有效连接维护一个表并且检查不符合列表规则的流入分组

**优点：**

1. **中等性能**：在运输层运行，检查TCP/UDP段的IP地址和端口号信息，相对分组过滤更安全，但性能比应用网关高。
2. **连接控制**：在内部主机和外部主机之间形成TCP中继连接，不允许内外部网络直接连接，增加了一层安全保障。
3. **适用性广**：通常与分组过滤结合使用，可以提供更全面的安全防护。

**缺点：**

1. **有限的深度检查**：只检查TCP/UDP段的IP地址和端口号信息，不检查应用层数据，无法检测应用层攻击。
2. **资源消耗**：需要维护一个有效连接表，对内存和CPU资源有一定消耗。
3. **配置复杂**：相对于无状态分组过滤，电路网关的配置和管理更加复杂。

---

#### 应用网关
+ 也叫做应用级网关或代理服务器
+ 扮演内部主机的代理角色, 处理来自外部客户端的服务请求
+ 对所有分组执行深度检查
	+ 检查应用程序格式
	+ 基于负载应用规则
	+ 具有检测恶意和可疑分组的能力
+ 对资源需求极为敏感

**优点：**

1. **高安全性**：对所有分组执行深度检查，检查应用程序格式，基于负载应用规则，能够检测恶意和可疑分组。
2. **代理功能**：扮演内部主机的代理角色，处理来自外部客户端的服务请求，提供更强的安全保护。
3. **细粒度控制**：能够对应用层数据进行详细检查和过滤，提供更细粒度的安全策略。

**缺点：**

1. **低性能**：由于需要对数据包的内容进行深入检查，处理速度慢，对网络性能影响较大。
2. **高复杂性**：配置和管理较复杂，可能需要客户端配置额外的代理软件。
3. **资源需求高**：对内存和CPU资源需求极大，可能会影响系统整体性能。


### 总结

- **分组过滤**：适用于对网络性能要求高且安全性要求相对较低的场景，配置简单但灵活性差。
- **电路网关**：适用于需要中等性能和安全性的场景，提供较好的连接控制但配置较复杂。
- **应用网关**：适用于对安全性要求极高且能接受性能损耗的场景，提供细粒度控制但对资源需求高，配置复杂。

选择哪种防火墙技术应根据具体的安全需求和网络性能要求来决定。
